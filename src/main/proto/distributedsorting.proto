syntax = "proto3";

package distributedsorting;

// =========================================================
// 1. 공통 데이터 타입 (Key)
// =========================================================

// Key 타입: 10바이트 Array[Byte]를 표현
// bytes 타입은 가변 길이지만, 프로젝트에서는 10바이트로 사용됨.
message KeyMessage {
    bytes value = 1;
}

// partition 결과 파일 id message
message FileIdMessage {
    int32 i = 1; // i'th node (파일을 생성한 워커 ID)
    int32 j = 2; // j'th partition (대상 워커 ID, 요청하는 워커)
    int32 k = 3; // k'th index file (같은 i→j에 대한 k번째 파일)
}

// =========================================================
// 2. 워커 -> 마스터 메시지
// =========================================================

// worker 정보를 담는 메시지
message WorkerInfo {
  int32 worker_id = 1;  // 워커 id
  string ip = 2;        // 워커의 IP 주소
  int32 port = 3;       // 워커가 데이터를 받을 Port (나중에 Shuffle 단계에서 필요할 수 있음)
}

// sampling: 데이터 수 통보를 위한 메시지
message RecordCountReport {
    string worker_id = 1;      // 워커 ID (등록된 워커임을 확인)
    int64 total_record_count = 2; // 워커가 가진 총 레코드 수 (n_i)
}

// sampling: 워커가 마스터에게 샘플링된 Key 리스트를 보낼 때 사용
message SampleKeyList {
    string worker_id = 1;
    repeated KeyMessage keys = 2;     // 샘플링된 Key들의 리스트
}

// 워커가 가지고 있는 FileId들을 보낼 때 사용
message FileIdRequest {
    int32 worker_id = 1;
    repeated FileIDMessage file_ids = 2;
}

// =========================================================
// 3. 마스터 -> 워커 메시지
// =========================================================

// Registration: 워커 등록 응답 메시지
message RegisterResponse {
  bool success = 1;     // 등록 성공 여부
  repeated WorkerInfo worker_list = 2;
}

// termination & communication: 종료 응답 메시지
message CompletionResponse {
    bool success = 1;
}

// sampling: 마스터가 워커에게 샘플링 비율을 보낼 때 사용
message SamplingRatio {
    double ratio = 1;          // 샘플링 확률 (k/n)
}

// sampling: 마스터가 워커에게 최종 파티션 정보와 순서를 보낼 때 사용
message PartitionInfo {
    // 마스터가 결정한 파티션 경계 Key 리스트 (W-1개)
    repeated KeyMessage pivots = 1; 
}

message SampleDecision {
    bool proceed = 1;                 // true: PartitionInfo를 사용 / false: 재샘플링 필요
    oneof content {
        PartitionInfo partition_info = 2; // proceed가 true일 때
        SamplingControl control = 3;      // proceed가 false일 때
    }
}
message SamplingControl {
    double new_ratio = 1;             // 재샘플링을 위한 새로운 확률 (Optional)
}

message FileIdList {
    repeated FileIDMessage file_ids = 1;
}

message FileIdMap {
    map<int32, FileIdList> file_ids = 1;
}

// =========================================================
// 4. 마스터 서비스 정의 (gRPC)
// =========================================================

service MasterService {
    // 워커가 마스터에게 등록할 때 호출하는 함수
    rpc RegisterWorker (WorkerInfo) returns (RegisterResponse);

    // 종료 보고
    rpc ReportCompletion (WorkerInfo) returns (CompletionResponse);

    // FileId들을 보고하고, map으로 응답
    rpc ReportFileIds (FileIdRequest) returns (FileIdMap);

    // 샘플링 비율 결정 단계
    // 등록된 워커가 자신의 레코드 수를 보고하고, 마스터는 샘플링 비율을 응답
    rpc ReportRecordCount (RecordCountReport) returns (SamplingRatio);
    
    // 최종 파티션 경계 결정 단계
    // 워커가 샘플 Key 리스트를 보고하고, 마스터는 최종 피벗 정보를 응답
    rpc SendSampleKeys (SampleKeyList) returns (SampleDecision);
}

// =========================================================
// 5. Shuffle Phase 워커 간 통신
// =========================================================

// 중간 파일 요청 메시지
message IntermediateFileRequest{
    int32 i = 1; // i'th node (파일을 생성한 워커 ID)
    int32 j = 2; // j'th partition (대상 워커 ID, 요청하는 워커)
    int32 k = 3; // k'th index file (같은 i→j에 대한 k번째 파일)
}

// 중간 파일 응답 메시지 (단일 응답 - 작은 파일용, deprecated)
message IntermediateFileResponse {
    bytes data = 1;        // 파일 데이터
    bool success = 2;      // 성공 여부
    string error_msg = 3;  // 에러 메시지 (실패 시)
}

// 파일 청크 메시지 (streaming용)
message FileChunk {
    bytes data = 1;           // 청크 데이터
    int64 chunk_index = 2;    // 청크 순서 (0부터 시작)
    int64 total_size = 3;     // 전체 파일 크기 (첫 청크에만 포함)
    bool is_last = 4;         // 마지막 청크 여부
    string error_msg = 5;     // 에러 메시지 (에러 발생 시)
}

// 워커 간 파일 교환을 위한 서비스
service WorkerService {
    // 다른 워커로부터 중간 파일을 요청 (단일 응답 - 작은 파일용)
    // 4MB 이하의 파일에 적합
    rpc GetIntermediateFile (IntermediateFileRequest) returns (IntermediateFileResponse);

    // 다른 워커로부터 중간 파일을 스트리밍으로 요청 (대용량 파일용)
    // 파일을 청크 단위로 나누어 전송하여 메모리 효율적
    rpc GetIntermediateFileStream (IntermediateFileRequest) returns (stream FileChunk);
}